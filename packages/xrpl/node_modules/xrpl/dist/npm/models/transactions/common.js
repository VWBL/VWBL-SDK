"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAmountValue = exports.validateBaseTransaction = exports.validateOptionalField = exports.validateRequiredField = exports.isXChainBridge = exports.isAmount = exports.isAccount = exports.isIssuedCurrency = exports.isCurrency = exports.isNumber = exports.isString = void 0;
const ripple_address_codec_1 = require("ripple-address-codec");
const ripple_binary_codec_1 = require("ripple-binary-codec");
const errors_1 = require("../../errors");
const utils_1 = require("../utils");
const MEMO_SIZE = 3;
function isMemo(obj) {
    if (obj.Memo == null) {
        return false;
    }
    const memo = obj.Memo;
    const size = Object.keys(memo).length;
    const validData = memo.MemoData == null || typeof memo.MemoData === 'string';
    const validFormat = memo.MemoFormat == null || typeof memo.MemoFormat === 'string';
    const validType = memo.MemoType == null || typeof memo.MemoType === 'string';
    return (size >= 1 &&
        size <= MEMO_SIZE &&
        validData &&
        validFormat &&
        validType &&
        (0, utils_1.onlyHasFields)(memo, ['MemoFormat', 'MemoData', 'MemoType']));
}
const SIGNER_SIZE = 3;
function isSigner(obj) {
    const signerWrapper = obj;
    if (signerWrapper.Signer == null) {
        return false;
    }
    const signer = signerWrapper.Signer;
    return (Object.keys(signer).length === SIGNER_SIZE &&
        typeof signer.Account === 'string' &&
        typeof signer.TxnSignature === 'string' &&
        typeof signer.SigningPubKey === 'string');
}
const XRP_CURRENCY_SIZE = 1;
const ISSUE_SIZE = 2;
const ISSUED_CURRENCY_SIZE = 3;
const XCHAIN_BRIDGE_SIZE = 4;
function isRecord(value) {
    return value !== null && typeof value === 'object';
}
function isString(str) {
    return typeof str === 'string';
}
exports.isString = isString;
function isNumber(num) {
    return typeof num === 'number';
}
exports.isNumber = isNumber;
function isCurrency(input) {
    return (isRecord(input) &&
        ((Object.keys(input).length === ISSUE_SIZE &&
            typeof input.issuer === 'string' &&
            typeof input.currency === 'string') ||
            (Object.keys(input).length === XRP_CURRENCY_SIZE &&
                input.currency === 'XRP')));
}
exports.isCurrency = isCurrency;
function isIssuedCurrency(input) {
    return (isRecord(input) &&
        Object.keys(input).length === ISSUED_CURRENCY_SIZE &&
        typeof input.value === 'string' &&
        typeof input.issuer === 'string' &&
        typeof input.currency === 'string');
}
exports.isIssuedCurrency = isIssuedCurrency;
function isAccount(account) {
    return (typeof account === 'string' &&
        ((0, ripple_address_codec_1.isValidClassicAddress)(account) || (0, ripple_address_codec_1.isValidXAddress)(account)));
}
exports.isAccount = isAccount;
function isAmount(amount) {
    return typeof amount === 'string' || isIssuedCurrency(amount);
}
exports.isAmount = isAmount;
function isXChainBridge(input) {
    return (isRecord(input) &&
        Object.keys(input).length === XCHAIN_BRIDGE_SIZE &&
        typeof input.LockingChainDoor === 'string' &&
        isCurrency(input.LockingChainIssue) &&
        typeof input.IssuingChainDoor === 'string' &&
        isCurrency(input.IssuingChainIssue));
}
exports.isXChainBridge = isXChainBridge;
function validateRequiredField(tx, paramName, checkValidity) {
    if (tx[paramName] == null) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: missing field ${paramName}`);
    }
    if (!checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
    }
}
exports.validateRequiredField = validateRequiredField;
function validateOptionalField(tx, paramName, checkValidity) {
    if (tx[paramName] !== undefined && !checkValidity(tx[paramName])) {
        throw new errors_1.ValidationError(`${tx.TransactionType}: invalid field ${paramName}`);
    }
}
exports.validateOptionalField = validateOptionalField;
function validateBaseTransaction(common) {
    if (common.TransactionType === undefined) {
        throw new errors_1.ValidationError('BaseTransaction: missing field TransactionType');
    }
    if (typeof common.TransactionType !== 'string') {
        throw new errors_1.ValidationError('BaseTransaction: TransactionType not string');
    }
    if (!ripple_binary_codec_1.TRANSACTION_TYPES.includes(common.TransactionType)) {
        throw new errors_1.ValidationError('BaseTransaction: Unknown TransactionType');
    }
    validateRequiredField(common, 'Account', isString);
    validateOptionalField(common, 'Fee', isString);
    validateOptionalField(common, 'Sequence', isNumber);
    validateOptionalField(common, 'AccountTxnID', isString);
    validateOptionalField(common, 'LastLedgerSequence', isNumber);
    const memos = common.Memos;
    if (memos !== undefined && !memos.every(isMemo)) {
        throw new errors_1.ValidationError('BaseTransaction: invalid Memos');
    }
    const signers = common.Signers;
    if (signers !== undefined &&
        (signers.length === 0 || !signers.every(isSigner))) {
        throw new errors_1.ValidationError('BaseTransaction: invalid Signers');
    }
    validateOptionalField(common, 'SourceTag', isNumber);
    validateOptionalField(common, 'SigningPubKey', isString);
    validateOptionalField(common, 'TicketSequence', isNumber);
    validateOptionalField(common, 'TxnSignature', isString);
    validateOptionalField(common, 'NetworkID', isNumber);
}
exports.validateBaseTransaction = validateBaseTransaction;
function parseAmountValue(amount) {
    if (!isAmount(amount)) {
        return NaN;
    }
    if (typeof amount === 'string') {
        return parseFloat(amount);
    }
    return parseFloat(amount.value);
}
exports.parseAmountValue = parseAmountValue;
//# sourceMappingURL=common.js.map