"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Meta = void 0;
const debug_1 = require("debug");
const fetch_ponyfill_1 = __importDefault(require("fetch-ponyfill"));
const { fetch, Request, Response, Headers } = fetch_ponyfill_1.default();
const os_browserify_1 = require("os-browserify");
const utils_1 = require("./utils");
const index_1 = require("./index");
const log = debug_1.debug('xumm-sdk:meta');
class Meta {
    constructor(apiKey, apiSecret) {
        this.isBrowser = false;
        this.jwtFlow = false;
        // Dependency injection: parent
        this.injected = false;
        this.endpoint = 'https://xumm.app';
        log('Constructed');
        const uuidRe = new RegExp('^[a-f0-9]{8}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{4}\-[a-f0-9]{12}$');
        const secret = {
            split: apiSecret.split(':'),
            uuidv4: ''
        };
        if (secret.split.length === 3 && secret.split.slice(0, 2).join(':') === 'xApp:OneTimeToken') {
            // xApp JWT flow
            secret.uuidv4 = secret.split[2];
            this.jwtFlow = true;
        }
        else if (secret.split.length > 1 && secret.split[0] === 'RAWJWT') {
            this.jwtFlow = true;
            this.jwt = secret.split.slice(1).join(':');
        }
        else {
            // Regular SDK/API calls
            secret.uuidv4 = apiSecret;
        }
        if (!uuidRe.test(apiKey) || !uuidRe.test(secret.uuidv4)) {
            if (!this.jwtFlow) {
                throw new Error('Invalid API Key and/or API Secret. Use dotenv or constructor params.');
            }
            else {
                if (!this.jwt) {
                    throw new Error('Invalid API Key and/or OTT (One Time Token). ' +
                        'Provide OTT param (2nd param) or make sure `xAppToken` query param is present (Browser)');
                }
            }
        }
        if (typeof globalThis !== 'undefined' && Object.keys(globalThis).indexOf('window') < 0) {
            log('Running in node');
        }
        else {
            console.log('XUMM SDK: Running in browser');
            this.isBrowser = true;
        }
        this.apiKey = apiKey;
        this.apiSecret = secret.uuidv4;
        if (this.jwtFlow && !this.jwt) {
            // Allow calls to wait for JWT
            this.authPromise = new Promise(resolve => {
                this.authPromiseResolve = resolve;
            });
            // Eventloop: wait for _inject @ index.ts (XummSdk Constructor) to have happened
            Promise.resolve()
                .then(() => this.authorize())
                .catch(e => {
                log('Authorize error:', e.message);
                if (this === null || this === void 0 ? void 0 : this.invoker) {
                    this.invoker.caught(e);
                }
                if (this.authPromiseResolve) {
                    this.authPromiseResolve();
                }
            });
        }
        return this;
    }
    setEndpoint(endpoint) {
        if (endpoint.match(/^http/)) {
            this.endpoint = endpoint.trim();
            return true;
        }
        return false;
    }
    authorize() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            log('JWT Authorize', this.apiSecret);
            let store;
            if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt) {
                store = this.invoker._jwtStore(this, (jwt) => this.jwt = jwt);
            }
            const authorizeData = (store === null || store === void 0 ? void 0 : store.get(this.apiSecret)) || (yield this.call('authorize'));
            if ((_b = (_a = authorizeData) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) {
                log(`Could not resolve API Key & OTT to JWT (already fetched? Unauthorized?)`);
                if ((this === null || this === void 0 ? void 0 : this.invoker) && this.invoker.constructor === index_1.XummSdkJwt && ((_c = this === null || this === void 0 ? void 0 : this.invoker) === null || _c === void 0 ? void 0 : _c.fatalHandler)) {
                    this.invoker.fatalHandler(new Error(authorizeData.error.reference));
                }
                else {
                    utils_1.throwIfError(authorizeData);
                }
            }
            else if ((_d = authorizeData) === null || _d === void 0 ? void 0 : _d.jwt) {
                const JwtOttResponse = authorizeData;
                store === null || store === void 0 ? void 0 : store.set(this.apiSecret, JwtOttResponse);
            }
            else {
                throw new Error(`Unexpected response for xApp JWT authorize request`);
            }
            if (this.authPromiseResolve) {
                this.authPromiseResolve();
            }
        });
    }
    call(endpoint, httpMethod = 'GET', data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const method = httpMethod.toUpperCase();
            const trEndpoint = endpoint.split('/')[0];
            if (this.jwtFlow && !(this === null || this === void 0 ? void 0 : this.jwt) && this.authPromise && endpoint !== 'authorize') {
                yield this.authPromise;
            }
            try {
                let body;
                if (typeof data !== 'undefined') {
                    if (typeof data === 'object' && data !== null) {
                        body = JSON.stringify(data);
                    }
                    if (typeof data === 'string') {
                        body = data;
                    }
                }
                const headers = {
                    'Content-Type': 'application/json'
                };
                if (!this.isBrowser) {
                    Object.assign(headers, {
                        'User-Agent': `xumm-sdk/node (${os_browserify_1.hostname()}) node-fetch`
                    });
                }
                if (!this.jwtFlow) {
                    Object.assign(headers, {
                        'x-api-key': this.apiKey,
                        'x-api-secret': this.apiSecret
                    });
                }
                else {
                    if (endpoint === 'authorize') {
                        Object.assign(headers, {
                            'x-api-key': this.apiKey,
                            'x-api-ott': this.apiSecret
                        });
                    }
                    else {
                        Object.assign(headers, {
                            'Authorization': 'Bearer ' + this.jwt
                        });
                    }
                }
                const jwtEndpoints = [
                    'authorize',
                    'ping',
                    'curated-assets',
                    'rates',
                    'payload',
                    'userdata',
                    'xrpl-tx',
                    'nftoken-detail',
                    'rails',
                    'hookhash'
                ];
                const endpointType = this.jwtFlow && jwtEndpoints.indexOf(trEndpoint) > -1
                    ? 'jwt'
                    : 'platform';
                const request = yield fetch(this.endpoint + '/api/v1/' + endpointType + '/' + endpoint, {
                    method,
                    body,
                    headers
                });
                const json = yield request.json();
                // log({json})
                return json;
            }
            catch (e) {
                const err = new Error(`Unexpected response from XUMM API [${method}:${trEndpoint}]`);
                err.stack = ((_a = e) === null || _a === void 0 ? void 0 : _a.stack) || undefined;
                throw err;
            }
        });
    }
    ping() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const pong = yield this.call('ping');
            utils_1.throwIfError(pong);
            if (typeof pong.auth !== 'undefined') {
                return pong.auth;
            }
            if (typeof ((_a = pong) === null || _a === void 0 ? void 0 : _a.ott_uuidv4) !== 'undefined') {
                // return pong as xAppJwtPong
                return {
                    application: {
                        uuidv4: pong.app_uuidv4,
                        name: pong.app_name
                    },
                    jwtData: pong
                };
            }
            if (typeof ((_b = pong) === null || _b === void 0 ? void 0 : _b.usertoken_uuidv4) !== 'undefined') {
                // return pong as JwtPong
                return {
                    application: {
                        uuidv4: pong.client_id,
                        name: pong.app_name
                    },
                    jwtData: pong
                };
            }
            throw new Error(`Unexpected response for ping request`);
        });
    }
    getCuratedAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('curated-assets');
        });
    }
    getRates(currencyCode) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('rates/' + currencyCode.trim().toUpperCase());
        });
    }
    getKycStatus(userTokenOrAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (userTokenOrAccount.trim().match(/^r/)) {
                const call = yield this.call('kyc-status/' + userTokenOrAccount.trim());
                return (call === null || call === void 0 ? void 0 : call.kycApproved) ? 'SUCCESSFUL' : 'NONE';
            }
            else {
                const call = yield this.call('kyc-status', 'POST', {
                    user_token: userTokenOrAccount
                });
                return (call === null || call === void 0 ? void 0 : call.kycStatus) || 'NONE';
            }
        });
    }
    getRails() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('rails');
        });
    }
    getHookHash(hookHash) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof hookHash === 'string' && hookHash.trim().match(/^[A-Fa-f0-9]{64}$/)) {
                return yield this.call('hookhash/' + hookHash.trim());
            }
            throw Error('Invalid Hook Hash (expecting 64 char hex)');
        });
    }
    getHookHashes() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('hookhash');
        });
    }
    getTransaction(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.call('xrpl-tx/' + txHash.trim());
        });
    }
    getNftokenDetail(tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.jwtFlow) {
                throw new Error('getNftokenDetail: only available in JWT (XummSdkJwt) mode');
            }
            return yield this.call('nftoken-detail/' + tokenId.trim());
        });
    }
    verifyUserTokens(userTokens) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.call('user-tokens', 'POST', {
                tokens: Array.isArray(userTokens) ? userTokens : [userTokens]
            })).tokens;
        });
    }
    // Internal
    _inject(Invoker) {
        if (!this.injected) {
            this.invoker = Invoker;
        }
        else {
            throw new Error('Cannot `_inject` twice');
        }
    }
}
exports.Meta = Meta;
