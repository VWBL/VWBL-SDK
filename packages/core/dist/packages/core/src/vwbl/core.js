"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VWBLCore = void 0;
const storage_1 = require("../storage");
const ipfs_1 = require("../storage/ipfs");
const util_1 = require("../util");
const types_1 = require("./types");
class VWBLCore {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    constructor(props) {
        /**
         * Uplod Metadata
         *
         * @remarks
         * By default, metadata will be uploaded to Amazon S3.
         * You need to pass `uploadMetadataCallBack` if you upload metadata to a storage other than Amazon S3.
         *
         * @param tokenId - The ID of NFT
         * @param name - The NFT name
         * @param description - The NFT description
         * @param thumbnailImageUrl - The URL of the thumbnail image
         * @param encryptedDataUrls - The URL of the encrypted file data
         * @param mimeType - The mime type of encrypted file data
         * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
         * @param uploadMetadataCallBack - Optional: the function for uploading metadata
         */
        this.uploadMetadata = (tokenId, name, description, thumbnailImageUrl, encryptedDataUrls, mimeType, encryptLogic, uploadMetadataCallBack) => __awaiter(this, void 0, void 0, function* () {
            const uploadMetadataFunction = this.uploadMetadataType === types_1.UploadMetadataType.S3 ? storage_1.uploadMetadata : uploadMetadataCallBack;
            if (!uploadMetadataFunction) {
                throw new Error("please specify upload metadata type or give callback");
            }
            yield uploadMetadataFunction(tokenId, name, description, thumbnailImageUrl, encryptedDataUrls, mimeType, encryptLogic, this.awsConfig);
        });
        /**
         * Uplod Metadata to IPFS
         *
         * @remarks
         * Metadata will be uploaded to IPFS.
         *
         * @param tokenId - The ID of NFT
         * @param name - The NFT name
         * @param description - The NFT description
         * @param thumbnailImageUrl - The URL of the thumbnail image
         * @param encryptedDataUrls - The URL of the encrypted file data
         * @param mimeType - The mime type of encrypted file data
         * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
         */
        this.uploadMetadataToIPFS = (name, description, thumbnailImageUrl, encryptedDataUrls, mimeType, encryptLogic) => __awaiter(this, void 0, void 0, function* () {
            const metadataUrl = yield (0, ipfs_1.uploadMetadataToIPFS)(name, description, thumbnailImageUrl, encryptedDataUrls, mimeType, encryptLogic, this.ipfsConfig);
            return metadataUrl;
        });
        /**
         * Create a key used for encryption and decryption
         *
         * @returns Random string generated by uuid
         */
        this.createKey = () => {
            return (0, util_1.createRandomKey)();
        };
        /**
         * Encode `plainData` to Base64 and encrypt it
         *
         * @param plainData - The data that only NFT owner can view
         * @param key - The key generated by {@link VWBL.createKey}
         * @returns Encrypted file data
         */
        this.encryptDataViaBase64 = (plainData, key) => __awaiter(this, void 0, void 0, function* () {
            const content = yield (0, util_1.toBase64FromFile)(plainData);
            return (0, util_1.encryptString)(content, key);
        });
        /**
         * Encrypt `plainData`
         *
         * @param plainFile - The data that only NFT owner can view
         * @param key - The key generated by {@link VWBL.createKey}
         * @returns Encrypted file data
         */
        this.encryptFile = (plainFile, key) => __awaiter(this, void 0, void 0, function* () {
            return (0, util_1.encryptFile)(plainFile, key);
        });
        /**
         * Decrypt `encryptFile`
         *
         * @param encryptFile - The data that only NFT owner can view
         * @param key - The key generated by {@link VWBL.createKey}
         * @returns Encrypted file data
         */
        this.decryptFile = (encryptFile, key) => __awaiter(this, void 0, void 0, function* () {
            return (0, util_1.decryptFile)(encryptFile, key);
        });
        /**
         * Encrypt `plainData`
         *
         * @param plainFile - The data that only NFT owner can view
         * @param key - The key generated by {@link VWBL.createKey}
         * @returns Encrypted file data
         */
        this.encryptStream = (plainFile, key) => {
            return (0, util_1.encryptStream)(plainFile, key);
        };
        /**
         * Decrypt `encryptFile`
         *
         * @param encryptFile - The data that only NFT owner can view
         * @param key - The key generated by {@link VWBL.createKey}
         * @returns Encrypted file data
         */
        this.decryptStream = (encryptFile, key) => {
            return (0, util_1.decryptStream)(encryptFile, key);
        };
        const { uploadContentType, uploadMetadataType, awsConfig, ipfsConfig } = props;
        this.uploadMetadataType = uploadMetadataType;
        if (uploadContentType === types_1.UploadContentType.S3 || uploadMetadataType === types_1.UploadMetadataType.S3) {
            if (!awsConfig) {
                throw new Error("please specify S3 bucket.");
            }
            this.awsConfig = awsConfig;
        }
        else if (uploadContentType === types_1.UploadContentType.IPFS || uploadMetadataType === types_1.UploadMetadataType.IPFS) {
            if (!ipfsConfig) {
                throw new Error("please specify pinata config of IPFS.");
            }
            this.ipfsConfig = ipfsConfig;
        }
    }
}
exports.VWBLCore = VWBLCore;
//# sourceMappingURL=core.js.map