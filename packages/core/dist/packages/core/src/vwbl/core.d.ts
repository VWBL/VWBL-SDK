/// <reference types="node" />
import * as Stream from "stream";
import { CoreConstructorProps, EncryptLogic, UploadMetadata } from "./types";
export declare class VWBLCore {
    private uploadMetadataType;
    private awsConfig?;
    private ipfsConfig?;
    constructor(props: CoreConstructorProps);
    /**
     * Uplod Metadata
     *
     * @remarks
     * By default, metadata will be uploaded to Amazon S3.
     * You need to pass `uploadMetadataCallBack` if you upload metadata to a storage other than Amazon S3.
     *
     * @param tokenId - The ID of NFT
     * @param name - The NFT name
     * @param description - The NFT description
     * @param thumbnailImageUrl - The URL of the thumbnail image
     * @param encryptedDataUrls - The URL of the encrypted file data
     * @param mimeType - The mime type of encrypted file data
     * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
     * @param uploadMetadataCallBack - Optional: the function for uploading metadata
     */
    uploadMetadata: (tokenId: number, name: string, description: string, thumbnailImageUrl: string, encryptedDataUrls: string[], mimeType: string, encryptLogic: EncryptLogic, uploadMetadataCallBack?: UploadMetadata) => Promise<void>;
    /**
     * Uplod Metadata to IPFS
     *
     * @remarks
     * Metadata will be uploaded to IPFS.
     *
     * @param tokenId - The ID of NFT
     * @param name - The NFT name
     * @param description - The NFT description
     * @param thumbnailImageUrl - The URL of the thumbnail image
     * @param encryptedDataUrls - The URL of the encrypted file data
     * @param mimeType - The mime type of encrypted file data
     * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
     */
    uploadMetadataToIPFS: (name: string, description: string, thumbnailImageUrl: string, encryptedDataUrls: string[], mimeType: string, encryptLogic: EncryptLogic) => Promise<string>;
    /**
     * Create a key used for encryption and decryption
     *
     * @returns Random string generated by uuid
     */
    createKey: () => string;
    /**
     * Encode `plainData` to Base64 and encrypt it
     *
     * @param plainData - The data that only NFT owner can view
     * @param key - The key generated by {@link VWBL.createKey}
     * @returns Encrypted file data
     */
    encryptDataViaBase64: (plainData: File, key: string) => Promise<string>;
    /**
     * Encrypt `plainData`
     *
     * @param plainFile - The data that only NFT owner can view
     * @param key - The key generated by {@link VWBL.createKey}
     * @returns Encrypted file data
     */
    encryptFile: (plainFile: File, key: string) => Promise<ArrayBuffer>;
    /**
     * Decrypt `encryptFile`
     *
     * @param encryptFile - The data that only NFT owner can view
     * @param key - The key generated by {@link VWBL.createKey}
     * @returns Encrypted file data
     */
    decryptFile: (encryptFile: Uint8Array, key: string) => Promise<ArrayBuffer>;
    /**
     * Encrypt `plainData`
     *
     * @param plainFile - The data that only NFT owner can view
     * @param key - The key generated by {@link VWBL.createKey}
     * @returns Encrypted file data
     */
    encryptStream: (plainFile: Stream, key: string) => Stream;
    /**
     * Decrypt `encryptFile`
     *
     * @param encryptFile - The data that only NFT owner can view
     * @param key - The key generated by {@link VWBL.createKey}
     * @returns Encrypted file data
     */
    decryptStream: (encryptFile: Stream, key: string) => Stream;
}
