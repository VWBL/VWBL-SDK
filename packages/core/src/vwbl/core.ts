import * as Stream from "stream";

import { AWSConfig, uploadMetadata } from "../storage";
import { IPFSConfig } from "../storage/ipfs";
import { uploadMetadataToIPFS } from "../storage/ipfs";
import {
  createRandomKey,
  decryptFile,
  decryptStream,
  encryptFile,
  encryptStream,
  encryptString,
  toBase64FromFile,
} from "../util";
import { CoreConstructorProps, EncryptLogic, UploadContentType, UploadMetadata, UploadMetadataType } from "./types";

export class VWBLCore {
  private uploadMetadataType: UploadMetadataType;
  private awsConfig?: AWSConfig;
  private ipfsConfig?: IPFSConfig;
  
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor(props: CoreConstructorProps) {
    const { uploadContentType, uploadMetadataType, awsConfig, ipfsConfig } = props;
    this.uploadMetadataType = uploadMetadataType;
    if (uploadContentType === UploadContentType.S3 || uploadMetadataType === UploadMetadataType.S3) {
      if (!awsConfig) {
        throw new Error("please specify S3 bucket.");
      }
      this.awsConfig = awsConfig;
    } else if (uploadContentType === UploadContentType.IPFS || uploadMetadataType === UploadMetadataType.IPFS) {
      if (!ipfsConfig) {
        throw new Error("please specify pinata config of IPFS.");
      }
      this.ipfsConfig = ipfsConfig;
    }
  }

  /**
   * Uplod Metadata
   *
   * @remarks
   * By default, metadata will be uploaded to Amazon S3.
   * You need to pass `uploadMetadataCallBack` if you upload metadata to a storage other than Amazon S3.
   *
   * @param tokenId - The ID of NFT
   * @param name - The NFT name
   * @param description - The NFT description
   * @param thumbnailImageUrl - The URL of the thumbnail image
   * @param encryptedDataUrls - The URL of the encrypted file data
   * @param mimeType - The mime type of encrypted file data
   * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
   * @param uploadMetadataCallBack - Optional: the function for uploading metadata
   */
  uploadMetadata = async (
    tokenId: number,
    name: string,
    description: string,
    thumbnailImageUrl: string,
    encryptedDataUrls: string[],
    mimeType: string,
    encryptLogic: EncryptLogic,
    uploadMetadataCallBack?: UploadMetadata
  ): Promise<void> => {
    const uploadMetadataFunction =
      this.uploadMetadataType === UploadMetadataType.S3 ? uploadMetadata : uploadMetadataCallBack;
    if (!uploadMetadataFunction) {
      throw new Error("please specify upload metadata type or give callback");
    }
    await uploadMetadataFunction(
      tokenId,
      name,
      description,
      thumbnailImageUrl,
      encryptedDataUrls,
      mimeType,
      encryptLogic,
      this.awsConfig 
    );
  };

  /**
   * Uplod Metadata to IPFS
   *
   * @remarks
   * Metadata will be uploaded to IPFS.
   *
   * @param tokenId - The ID of NFT
   * @param name - The NFT name
   * @param description - The NFT description
   * @param thumbnailImageUrl - The URL of the thumbnail image
   * @param encryptedDataUrls - The URL of the encrypted file data
   * @param mimeType - The mime type of encrypted file data
   * @param encryptLogic - Select ether "base64" or "binary". Selection criteria: "base64" -> sutable for small data. "binary" -> sutable for large data.
   */
  uploadMetadataToIPFS = async (
    name: string,
    description: string,
    thumbnailImageUrl: string,
    encryptedDataUrls: string[],
    mimeType: string,
    encryptLogic: EncryptLogic
  ): Promise<string> => {
    const metadataUrl = await uploadMetadataToIPFS(
      name,
      description,
      thumbnailImageUrl,
      encryptedDataUrls,
      mimeType,
      encryptLogic,
      this.ipfsConfig
    );
    return metadataUrl;
  };

  /**
   * Create a key used for encryption and decryption
   *
   * @returns Random string generated by uuid
   */
  createKey = (): string => {
    return createRandomKey();
  };

  /**
   * Encode `plainData` to Base64 and encrypt it
   *
   * @param plainData - The data that only NFT owner can view
   * @param key - The key generated by {@link VWBL.createKey}
   * @returns Encrypted file data
   */
  encryptDataViaBase64 = async (plainData: File, key: string): Promise<string> => {
    const content = await toBase64FromFile(plainData);
    return encryptString(content, key);
  };

  /**
   * Encrypt `plainData`
   *
   * @param plainFile - The data that only NFT owner can view
   * @param key - The key generated by {@link VWBL.createKey}
   * @returns Encrypted file data
   */
  encryptFile = async (plainFile: File, key: string): Promise<ArrayBuffer> => {
    return encryptFile(plainFile, key);
  };

  /**
   * Decrypt `encryptFile`
   *
   * @param encryptFile - The data that only NFT owner can view
   * @param key - The key generated by {@link VWBL.createKey}
   * @returns Encrypted file data
   */
  decryptFile = async (encryptFile: Uint8Array, key: string): Promise<ArrayBuffer> => {
    return decryptFile(encryptFile, key);
  };

  /**
   * Encrypt `plainData`
   *
   * @param plainFile - The data that only NFT owner can view
   * @param key - The key generated by {@link VWBL.createKey}
   * @returns Encrypted file data
   */
  encryptStream = (plainFile: Stream, key: string): Stream => {
    return encryptStream(plainFile, key);
  };

  /**
   * Decrypt `encryptFile`
   *
   * @param encryptFile - The data that only NFT owner can view
   * @param key - The key generated by {@link VWBL.createKey}
   * @returns Encrypted file data
   */
  decryptStream = (encryptFile: Stream, key: string): Stream => {
    return decryptStream(encryptFile, key);
  };
}